MONGODB Structure:
Client -> Databases -> Collections -> Individual Documents (contain json similar data)
We call Client['database'] to enter. Then navigate through collections & documents for data.

Documents need to be "found" using this func before you can print them. collection.find_one() returns the first. 
Otherwise you need to query for the rest.
You can chose to either use .find_one() or do find() to return all possible matches.
document = collection.find_one()
print(document['_id'], document['email'])

collection.find() is like opening the folder. Then all the documents will be accessible.
users = collection.find()
Print all users
for document in users:
    print(document)

To search by id you need to user the ObjectID() wrapper from bson.objectid
robert = collection.find_one({'_id': ObjectId("id you copied from mongodb")})
print(robert)

If you want to find multiple of the same doc just use .find() It will return a list sort of
jay_doc = collection.find({'name': 'Jay Noppone'})
for x in jay_doc:
    print(x)

Check if a document exists:
myquery = { 'email-address' : "sam@gmail.com" }
if collection.count_documents(myquery, limit=1):
    print("Match was found")
else:
    print("No match was found.")

UPDATE PROCESS:
restaurants = database["restaurants"]
query_filter = {'name' : 'Bagels N Buns'}
update_operation = { '$set' : 
    { 'name' : '2 Bagels 2 Buns' }
}
result = restaurants.update_one(query_filter, update_operation)


Basically each endpoint on flask is its own function. If you reach that endpoint youll run any code associated with it.
This lets flask be the middle man between react & javascript :vomit: and python (blessed)


This block of code describes an endpoint called registry which is what we'll be making calls to.
If the api call is a GET request then it'll obviously return the GET block.

@app.route("/registry", methods=['GET', 'POST'])
def registry():
    if request.method == "GET":
        print("GET request received.")
        return "<p>Registry GET</p>"
    

    If its a POST request, request.data.decode() takes the posted content and converts it into a readable string
    Since we can expect that readable string to be JSON we use the JSON library to convert it into something we can
    easily sift through. 

    **request.data.decode** works for RAW data, there are other methods for the different types of post content.

    elif request.method == "POST":
        print("POST request recieved")
        x = request.data.decode()
        x = json.loads(x)

        print(x['name'])
        return "<p>Registry POST</p>"